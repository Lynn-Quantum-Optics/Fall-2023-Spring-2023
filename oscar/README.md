Hi, these are some notes by Oscar on his code for thesis. I will be adding more clarifications as I go on in the spring to make this code as useful to future generations as possible. :)

## 1/22/24
- started the file new_esym_general.py to generalize new_esym_6.py.
- successfully coded the correlation class code for any even dimension!!
- tried guess for some of the parans based on d = 6, but doesn't seem to be converging numerically in GD. also running w/o loss and looks to be converging.

## 1/20/24
- successfully found phase class for symmetric basis!!!!!! see new_esym_6.py. in optimize_phase() used trabbit and phase explicitly an eigenstate of particle exchange minimizing sum of abs value of inner prods; then used get_inner_prods() to evaluate the inner prods of the parametrized vectors I started with and when I substituted in my adapted numerical results from optimize_phase(). See inner_prod0, inner_prod1, inner_prod2, and final_phase for a record of the latex outputs.

## 1/19/24
- realized that by "symmetric basis", we mean eigenstate of particle exchange. played around with sample phase classes and found one numerically that satisfies orthogonality of the states up to 7e-9, and the eigenstate of exchange beyond 1e-33 (since they were specficially constructed to be eigenstates). all this code is in new_esym_6.py.

## 1/12/24
- trying to find symmetric basis for d = 4, using sym_test4.py. after talking to lynn: this has wrong intepretation of hyperentangled basis.

## 1/8/24
- built a lot more with detection2.py over the past couple of weeks. the main functions are: ```get_k()```, ```U_guess()```, and ```find_params()```. the master function is ```find_params()```, which will attempt to find the unitary in the form given by U_guess that will make the total overlap in detection signatures generated by ```get_k()``` 0.
- for U generation: i had been playing around with different ways of representing U, and the givens rotation was one of those ways. as of this date the code for the generation is still there, but ```U_guess()``` is preferred and the givens rotation code will be removed at some point.
- note about determinants and distinguishability: LELM doesn't require SU. by using the structure of U_act = U(d) \otimes U(d), then we are acting on the L and R channels without introducing conditional logic, so we're bing chillin.

## 12/28/23
- going back to understanding the action of different U on the bell states to produce detection signatures. what properties of U produce what detection signatures? --> detection2.py
- idea is to go back to original definition. use all different c classes in k group since that gives us >= 6. so question is how can we discriminate phase?

## 12/27/23
- added symmetrized.py and sym_new.py and sym_sym.py. symmetrized.py has code to check whether a state is fully entangled by computing the trace of the RDM^2, which should be 1/d for maximum entangled. it tried to find the offsets necessary to create a fully entangled symmetric basis.
- sym_sym.py used sympy to try to solve directly for a general symmetric condition.
- sym_new.py tried out my new correlation class idea and tested whether it could lead to a new symmetric fully entangled basis, but the problem is we can't get 6 independent phases due to the symmetry, so we end up only getting 3 independent phase classes if c > 0.

## 11/23/23:
- added su_parametrize.py and bell.py. su_parametrize expresses U as tensor product of SU(2) and SU(3) and then minimizes the number of overlapping signatures (using code from bell.py).
- problem: this parametrization won't account for all SU(6) matrices. result is that min value for num_overlap was when params = [all 0], so acting with identity matrix. will implement general SU(n) construction.

## 11/6/23:
- find_basis.py currently finds the local change of basis from standard to hyperentangled basis -> converts to tensor product of single particle basis
    - currently only works for d = 4 to d = 2, but will be generalized to any prime factorization
    - studying if we can recover d = 4 distinguishability by converting the beam splitter matrix to hyperentangled basis
- distinguish.py
    - determines detection signatures for groups of bell states given some SU(2d) matrix
    - working with find_basis.py results to determine generalizability of hyperentangled basis