Hi, these are some notes by Oscar on his code for thesis. I will be adding more clarifications as I go on in the spring to make this code as useful to future generations as possible. :)

1/8/24
- built a lot more with detection2.py over the past couple of weeks. the main functions are: ```get_k()```, ```U_guess()```, and ```find_params()```. the master function is ```find_params()```, which will attempt to find the unitary in the form given by U_guess that will make the total overlap in detection signatures generated by ```get_k()``` 0.
- for U generation: i had been playing around with different ways of representing U, and the givens rotation was one of those ways. as of this date the code for the generation is still there, but ```U_guess()``` is preferred and the givens rotation code will be removed at some point.
- note about determinants and distinguishability: LELM doesn't require SU. by using the structure of U_act = U(d) \otimes U(d), then we are acting on the L and R channels without introducing conditional logic, so we're bing chillin.

12/28/23
- going back to understanding the action of different U on the bell states to produce detection signatures. what properties of U produce what detection signatures? --> detection2.py
- idea is to go back to original definition. use all different c classes in k group since that gives us >= 6. so question is how can we discriminate phase?

12/27/23
- added symmetrized.py and sym_new.py and sym_sym.py. symmetrized.py has code to check whether a state is fully entangled by computing the trace of the RDM^2, which should be 1/d for maximum entangled. it tried to find the offsets necessary to create a fully entangled symmetric basis.
- sym_sym.py used sympy to try to solve directly for a general symmetric condition.
- sym_new.py tried out my new correlation class idea and tested whether it could lead to a new symmetric fully entangled basis, but the problem is we can't get 6 independent phases due to the symmetry, so we end up only getting 3 independent phase classes if c > 0.

11/23/23:
- added su_parametrize.py and bell.py. su_parametrize expresses U as tensor product of SU(2) and SU(3) and then minimizes the number of overlapping signatures (using code from bell.py).
- problem: this parametrization won't account for all SU(6) matrices. result is that min value for num_overlap was when params = [all 0], so acting with identity matrix. will implement general SU(n) construction.

11/6/23:
- find_basis.py currently finds the local change of basis from standard to hyperentangled basis -> converts to tensor product of single particle basis
    - currently only works for d = 4 to d = 2, but will be generalized to any prime factorization
    - studying if we can recover d = 4 distinguishability by converting the beam splitter matrix to hyperentangled basis
- distinguish.py
    - determines detection signatures for groups of bell states given some SU(2d) matrix
    - working with find_basis.py results to determine generalizability of hyperentangled basis